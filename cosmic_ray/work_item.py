"""Classes for describing work and results.
"""
import json
import pathlib

from cosmic_ray.util import StrEnum


class WorkerOutcome(StrEnum):
    """Possible outcomes for a worker.
    """
    NORMAL = 'normal'       # The worker exited normally, producing valid output
    EXCEPTION = 'exception'  # The worker exited with an exception
    ABNORMAL = 'abnormal'   # The worker did not exit normally or with an exception (e.g. a segfault)
    NO_TEST = 'no-test'     # The worker had no test to run
    SKIPPED = 'skipped'     # The job was skipped (worker was not executed)


class TestOutcome(StrEnum):
    """A enum of the possible outcomes for any mutant test run.
    """
    SURVIVED = 'survived'
    KILLED = 'killed'
    INCOMPETENT = 'incompetent'


class WorkResult:
    """The result of a single mutation and test run.
    """

    def __init__(self,
                 worker_outcome,
                 output=None,
                 test_outcome=None,
                 diff=None):
        if worker_outcome is None:
            raise ValueError('Worker outcome must always have a value.')

        self._output = output
        self._test_outcome = test_outcome
        self._worker_outcome = worker_outcome
        self._diff = diff

    @property
    def worker_outcome(self):
        "A `WorkerOutcome` indicating how the worker finished."
        return self._worker_outcome

    @property
    def test_outcome(self):
        "A `TestOutcome` indicating how the test runner finished. Possibly `None`."
        return self._test_outcome

    @property
    def output(self):
        "Any output returned by the test command. Possibly `None`."
        return self._output

    @property
    def diff(self):
        "A sequence of strings containing the diff generated by the mutation. Possibly `None`."
        return self._diff

    def as_dict(self):
        return {
            'output': self.output,
            'test_outcome': self.test_outcome,
            'worker_outcome': self.worker_outcome,
            'diff': self.diff,
        }

    @property
    def is_killed(self):
        "Whether the mutation should be considered 'killed'"
        if self.worker_outcome == WorkerOutcome.SKIPPED:
            return True
        elif self.worker_outcome in {WorkerOutcome.ABNORMAL, WorkerOutcome.NORMAL}:
            if self.test_outcome == TestOutcome.KILLED:
                return True
            if self.test_outcome == TestOutcome.INCOMPETENT:
                return True
        return False

    def __eq__(self, rhs):
        return self.as_dict() == rhs.as_dict()

    def __neq__(self, rhs):
        return not self == rhs


class WorkItem:
    """Description of the work for a single mutation and test run.
    """

    def __init__(self,
                 module_path=None,
                 operator_name=None,
                 occurrence=None,
                 start_pos=None,
                 stop_pos=None,
                 job_id=None):
        self._module_path = pathlib.Path(module_path)
        self._operator_name = operator_name
        self.occurrence = occurrence
        self._start_pos = start_pos
        self._stop_pos = stop_pos
        self._job_id = job_id

    @property
    def module_path(self):
        "pathlib.Path to module being mutated."
        return self._module_path

    @property
    def operator_name(self):
        "The name of the operator (i.e. as defined by the provider)"
        return self._operator_name

    @property
    def start_pos(self):
        "Start of the mutation location as a `(line, column)` tuple."
        return self._start_pos

    @property
    def stop_pos(self):
        "End of the mutation location as a `(line, column)` tuple."
        return self._stop_pos

    @property
    def job_id(self):
        "The unique ID of the job"
        return self._job_id

    def as_dict(self):
        """Get fields as a dict.
        """
        return {
            'module_path': str(self.module_path),
            'operator_name': self.operator_name,
            'occurrence': self.occurrence,
            'start_pos': self.start_pos,
            'stop_pos': self.stop_pos,
            'job_id': self.job_id,
        }

    def __eq__(self, rhs):
        return self.as_dict() == rhs.as_dict()

    def __neq__(self, rhs):
        return not self == rhs


class WorkItemJsonEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, WorkItem):
            return {
                "_type": "WorkItem",
                "values": o.as_dict()
            }
        elif isinstance(o, WorkResult):
            return {
                "_type": "WorkResult",
                "values": o.as_dict()
            }
        return super().default(o)


class WorkItemJsonDecoder(json.JSONDecoder):

    def __init__(self):
        json.JSONDecoder.__init__(self, object_hook=self.object_hook)

    def object_hook(self, obj):
        if (obj.get('_type') == 'WorkItem') and ('values' in obj):
            values = obj['values']
            return WorkItem(**values)
        elif (obj.get('_type') == 'WorkResult') and ('values' in obj):
            values = obj['values']
            return WorkResult(**values)
        return obj
